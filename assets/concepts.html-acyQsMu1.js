import{_ as i,r as a,o as n,c as d,a as e,b as o,d as r,e as t}from"./app-lnPknyyT.js";const c={},l=t('<h1 id="concepts" tabindex="-1"><a class="header-anchor" href="#concepts" aria-hidden="true">#</a> Concepts</h1><h2 id="imposters" tabindex="-1"><a class="header-anchor" href="#imposters" aria-hidden="true">#</a> Imposters</h2><p>Imposters are the most important concept in the Killgrave&#39;s world.</p><p>They conform the rules that determine how the mock server should respond to a request.</p><p>You can identify a Killgrave imposter file by its extension: <code>.imp.json</code>, <code>.imp.yml</code> or <code>.imp.yaml</code>.</p>',5),h={href:"/config/#imposters",target:"_blank",rel:"noopener noreferrer"},p=t('<h3 id="imposters-structure" tabindex="-1"><a class="header-anchor" href="#imposters-structure" aria-hidden="true">#</a> Imposters Structure</h3><p>The imposter object can be divided in two parts:</p><ul><li><a href="#request">Request</a></li><li><a href="#response">Response</a></li></ul><h4 id="request" tabindex="-1"><a class="header-anchor" href="#request" aria-hidden="true">#</a> Request</h4><p>This part defines how Killgrave should determine whether an incoming request matches the imposter or not.</p><p>The request object has the following properties:</p><ul><li><code>method</code> <em>(mandatory)</em>: The HTTP method of the incoming request.</li><li><code>endpoint</code> <em>(mandatory)</em>: Path of the endpoint relative to the base. Supports regular expressions.</li><li><code>schemaFile</code>: A JSON schema to validate the incoming request against.</li><li><code>params</code>: Restrict incoming requests by query parameters. Supports regular expressions.</li><li><code>headers</code>: Restrict incoming requests by HTTP header.</li></ul><h4 id="response" tabindex="-1"><a class="header-anchor" href="#response" aria-hidden="true">#</a> Response</h4><p>This part defines how Killgrave should, in case of match, respond to the incoming request.</p><p>The response object has the following properties:</p>',10),u=t("<li><code>status</code> <em>(mandatory)</em>: Integer defining the HTTP status code to return.</li><li><code>body</code> or <code>bodyFile</code>: The response body. Either a literal string (<code>body</code>) or a path to a file (<code>bodyFile</code>). <code>bodyFile</code> is especially useful in the case of large outputs. This property is optional: if not response body should be returned it should be removed or left empty.</li><li><code>headers</code>: HTTP headers to return in the response.</li>",3),m=e("code",null,"delay",-1),f={href:"https://pkg.go.dev/time#ParseDuration",target:"_blank",rel:"noopener noreferrer"},_=e("code",null,"time.ParseDuration",-1),b=e("code",null,":",-1),y=e("code",null,'"0s"',-1);function g(T,v){const s=a("ExternalLinkIcon");return n(),d("div",null,[l,e("blockquote",null,[e("p",null,[e("em",null,[o("You can learn more about how to configure imposters in the "),e("a",h,[o("Imposter Configuration Section"),r(s)]),o(".")])])]),p,e("ul",null,[u,e("li",null,[m,o(": Time the server waits before responding. This can help simulate network issues, or high server load. Uses the Go "),e("a",f,[_,r(s)]),o(" format. Also, you can specify minimum and maximum delays separated by "),b,o(". The response delay will be chosen randomly between these values. Default value is "),y,o(" (no delay).")])])])}const x=i(c,[["render",g],["__file","concepts.html.vue"]]);export{x as default};
